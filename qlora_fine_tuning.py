# -*- coding: utf-8 -*-
"""QLora_Fine_Tuning.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xQ_gRjHEutnOTqEr1uOSIV9mSl3u-1da
"""

!pip install -q -U bitsandbytes accelerate
!pip install -q -U transformers datasets peft
!pip install -q -U torch torchvision torchaudio
!pip install -q -U trl
import torch

from transformers import AutoModelForCausalLM, AutoTokenizer, BitsAndBytesConfig
from trl import SFTTrainer

!python -m bitsandbytes

from datasets import load_dataset
from transformers import TrainingArguments, Trainer
from peft import LoraConfig, get_peft_model

model_name = "TinyLlama/TinyLlama-1.1B-Chat-v1.0"
dataset = load_dataset("fka/awesome-chatgpt-prompts")
print(dataset['train'][0])
new_model = "finetuned_model"
OUTPUT_DIR = "./qlora-llama2-adapter"

bnb_config = BitsAndBytesConfig(
    load_in_4bit=True,  #quantize to 4 bit
    bnb_4bit_use_double_quant=True, #internally first quantize to 16 to 8. and then 8 to 4
    bnb_4bit_quant_type="nf4",   # smart compression that keeps important details.always use this.
    bnb_4bit_compute_dtype=torch.bfloat16
)

lora_config = LoraConfig(
    r = 8,
    lora_alpha = 32,
    lora_dropout = 0.1,
    bias = "none",
    task_type = "CAUSAL_LM",
    target_modules=[
    "q_proj", "k_proj", "v_proj", "o_proj",
    "gate_proj", "up_proj", "down_proj"
]
)

tokenizer = AutoTokenizer.from_pretrained(model_name)
tokenizer.pad_token = tokenizer.eos_token
tokenizer.padding_side = "right"

model = AutoModelForCausalLM.from_pretrained(
    model_name,
    quantization_config=bnb_config,
    device_map="auto",
    trust_remote_code=True,
    use_auth_token=userdata.get('HF_TOKEN') # Access the token from Colab secrets
)

model = get_peft_model(model, lora_config)

max_seq_length = 512

def tokenize_fn(batch):
    # Combine prompt and output if needed, here we only have 'prompt'
    inputs = batch['prompt']

    # Tokenize with padding and truncation
    tokenized = tokenizer(
        inputs,
        max_length=max_seq_length,
        padding="max_length",   # pad to max_seq_length
        truncation=True,
        return_tensors="pt"
    )

    # For causal LM, labels are same as input_ids
    tokenized["labels"] = tokenized["input_ids"].clone()

    # Convert tensors back to lists for datasets library
    tokenized = {k: v.tolist() for k, v in tokenized.items()}

    return tokenized

# Map the function over the dataset
tokenized_dataset = dataset.map(tokenize_fn, batched=True)
train_dataset = tokenized_dataset["train"]

training_arg = TrainingArguments(
    output_dir= OUTPUT_DIR,
    num_train_epochs= 3,
    per_device_eval_batch_size =
    per_device_train_batch_size=4,
     gradient_accumulation_steps=8,
    learning_rate=2e-4,
    fp16=not (torch.cuda.is_available() and torch.cuda.is_bf16_supported()),
    bf16=torch.cuda.is_available() and torch.cuda.is_bf16_supported(),
    logging_steps=10,
    save_steps=50,
    save_total_limit=2,
    optim="paged_adamw_32bit",
    report_to="tensorboard",  #Where to report logs (wandb, tensorboard, etc.).
    gradient_checkpointing=True,
    lr_scheduler_type="cosine",
    warmup_ratio=0.03,
    group_by_length=True, #For memory optimization

)

#epoch = number of time all the sample go through to the model(total_sam = 10k)
#step = A step (or iteration) happens every time the model processes one batch of data and updates its weights.if the batch size is 10, it means the model process 10 sample at a time. if that, one epoch happens for 100/10 = 10 steps.
#After each steps, model update its weight. instead of directly mentioning the batch size in each step we mention per_device_train and  gradient_accumulation_steps.batch size = gacumulator * per_device_batch. use for memory efficiency
#as in the colab. there are 1 gpu. so 2 samples are processed at a time. similarly, for the last 8 times, the gpu processed data and then the model update weight
#save steps= A checkpoint is basically a saved snapshot of your model during training.It includes things like: Model weights, Optimizer state (so training can resume exactly where it left off)
#Training happens in steps (remember: one batch update = one step).If you set save_steps = 50, then every 50 steps the trainer will save a checkpoint of the model.
# That way, even if Colab disconnects or crashes, you can reload the last checkpoint instead of starting over.
#You set save_steps = 100 and save_total_limit = 2. checkpoints would be saved at steps 100, 200, 300, 400, 500.But with save_total_limit=2, only the last 2 checkpoints are kept → step 400 and 500.
#learningrate, warmingup = Instead of keeping lr constant, we usually schedule it.Imagine you train for 10,000 steps: Warmup (first 3% = 300 steps): lr increases from 0 to max (e.g., 2e-4).
#Decay (remaining 9700 steps): lr follows the cosine curve down to near 0.as it follows cosine curve so the lr_scheduler is cosine

trainer = SFTTrainer(
    model=model,
    train_dataset=train_dataset,
    peft_config=lora_config,
    args=training_arg,

)

trainer.train()

trainer.model.save_pretrained(OUTPUT_DIR)
tokenizer.save_pretrained(OUTPUT_DIR)

from peft import PeftModel
from transformers import AutoModelForCausalLM, AutoTokenizer

base_model = AutoModelForCausalLM.from_pretrained(model_name, device_map="auto")
model = PeftModel.from_pretrained(base_model, OUTPUT_DIR)
tokenizer = AutoTokenizer.from_pretrained(OUTPUT_DIR)

prompt = "`position` Interviewer"
inputs = tokenizer(prompt, return_tensors="pt").to("cuda")
outputs = model.generate(**inputs, max_new_tokens=100)
print(tokenizer.decode(outputs[0], skip_special_tokens=True))

import random
import os
import re
import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import classification_report, confusion_matrix
import matplotlib.pyplot as plt
import seaborn as sns

import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import Dataset, DataLoader

from transformers import AutoTokenizer, AutoModelForSequenceClassification, BitsAndBytesConfig
from transformers import TrainingArguments, Trainer, logging as hf_logging
from peft import LoraConfig, get_peft_model, TaskType, prepare_model_for_kbit_training

hf_logging.set_verbosity_error()  # silence some HF logs

# ------------------- Reproducibility -------------------
SEED = 42
random.seed(SEED)
np.random.seed(SEED)
torch.manual_seed(SEED)
if torch.cuda.is_available():
    torch.cuda.manual_seed_all(SEED)

# ------------------- 1. Load & Clean Dataset -------------------
# Load training data
train_df = pd.read_csv("/content/blp25_1A_train.tsv.csv")
test_df = pd.read_csv("/content/blp25_1A_test.tsv.csv")
val_df = pd.read_csv("/content/subtask_1A_train_update.tsv.csv")

train_df['label'] = train_df['label'].fillna("None")
val_df['label'] = val_df['label'].fillna("None")

def clean_bengali_text(text):
    """Clean Bengali text while preserving Bengali characters"""
    text = str(text).strip()
    # Remove extra whitespaces
    text = re.sub(r'\s+', ' ', text)
    # Remove some common non-text characters but keep Bengali
    text = re.sub(r'[^\u0980-\u09FF\s\w]', '', text)
    return text

# Clean text data
train_df['text'] = train_df['text'].apply(clean_bengali_text)
val_df['text'] = val_df['text'].apply(clean_bengali_text)
test_df['text'] = test_df['text'].apply(clean_bengali_text)

# Combine train and val data for encoding, then split
combined_df = pd.concat([train_df, val_df], ignore_index=True)

# Encode labels - fit on combined, transform both
label_enc = LabelEncoder()
combined_df['label_encoded'] = label_enc.fit_transform(combined_df['label'])

# Get number of classes
num_classes = len(label_enc.classes_)
print(f"Number of classes: {num_classes}")
print(f"Class labels: {label_enc.classes_}")

# Split back into train and val
train_df_encoded = combined_df.iloc[:len(train_df)].copy()
val_df_encoded = combined_df.iloc[len(train_df):].copy()

train_texts = list(train_df['text'])
train_labels = list(train_df_encoded['label_encoded'])
val_texts = list(val_df['text'])
val_labels = list(val_df_encoded['label_encoded'])
test_texts = list(test_df['text'])

print(f"Training samples: {len(train_texts)}")
print(f"Validation samples: {len(val_texts)}")
print(f"Test samples: {len(test_texts)}")

# ------------------- 2. QLoRA Configuration -------------------
# Configure 4-bit quantization for QLoRA
quantization_config = BitsAndBytesConfig(
    load_in_4bit=True,                      # Enable 4-bit quantization
    bnb_4bit_quant_type="nf4",             # Use normalized float 4-bit
    bnb_4bit_compute_dtype=torch.float16,   # Computation dtype
    bnb_4bit_use_double_quant=True,        # Double quantization for better accuracy
)

# LoRA configuration for QLoRA
lora_config = LoraConfig(
    task_type=TaskType.SEQ_CLS,            # Sequence classification task
    inference_mode=False,                   # Training mode
    r=16,                                  # Rank of adaptation - higher = more parameters
    lora_alpha=32,                         # LoRA scaling parameter
    lora_dropout=0.1,                      # Dropout for LoRA layers
    target_modules=[                       # Which layers to apply LoRA to
        "query",
        "value",
        "key",
        "dense",
        "attention.output.dense",
        "intermediate.dense",
        "output.dense"
    ],
    bias="none",                           # Don't adapt bias parameters
)

print("QLoRA Configuration:")
print(f"- 4-bit quantization: {quantization_config.load_in_4bit}")
print(f"- LoRA rank: {lora_config.r}")
print(f"- LoRA alpha: {lora_config.lora_alpha}")
print(f"- Target modules: {lora_config.target_modules}")

# ------------------- 3. Load Model with QLoRA -------------------
MAX_LEN = 128
model_name = "sagorsarker/bangla-bert-base"

print(f"Loading Bangla BERT with QLoRA: {model_name}")

# Load tokenizer
tokenizer = AutoTokenizer.from_pretrained(model_name)
if tokenizer.pad_token is None:
    tokenizer.pad_token = tokenizer.eos_token

# Load model with quantization
base_model = AutoModelForSequenceClassification.from_pretrained(
    model_name,
    num_labels=num_classes,
    quantization_config=quantization_config,
    device_map="auto",                     # Automatically distribute across GPUs
    torch_dtype=torch.float16,
)

# Prepare model for k-bit training (required for QLoRA)
base_model = prepare_model_for_kbit_training(base_model)

# Add LoRA adapters
model = get_peft_model(base_model, lora_config)

# Print trainable parameters
def print_trainable_parameters(model):
    trainable_params = 0
    all_param = 0
    for _, param in model.named_parameters():
        all_param += param.numel()
        if param.requires_grad:
            trainable_params += param.numel()

    print(f"Trainable params: {trainable_params:,} || "
          f"All params: {all_param:,} || "
          f"Trainable%: {100 * trainable_params / all_param:.2f}%")

print_trainable_parameters(model)

# ------------------- 4. Dataset Class for Hugging Face Trainer -------------------
class BengaliDataset(Dataset):
    def __init__(self, texts, labels, tokenizer, max_length=128):
        self.texts = texts
        self.labels = labels
        self.tokenizer = tokenizer
        self.max_length = max_length

    def __len__(self):
        return len(self.texts)

    def __getitem__(self, idx):
        text = str(self.texts[idx])
        label = self.labels[idx]

        # Tokenize text
        encoding = self.tokenizer(
            text,
            truncation=True,
            padding='max_length',
            max_length=self.max_length,
            return_tensors='pt'
        )

        return {
            'input_ids': encoding['input_ids'].flatten(),
            'attention_mask': encoding['attention_mask'].flatten(),
            'labels': torch.tensor(label, dtype=torch.long)
        }

class TestDataset(Dataset):
    def __init__(self, texts, tokenizer, max_length=128):
        self.texts = texts
        self.tokenizer = tokenizer
        self.max_length = max_length

    def __len__(self):
        return len(self.texts)

    def __getitem__(self, idx):
        text = str(self.texts[idx])

        # Tokenize text
        encoding = self.tokenizer(
            text,
            truncation=True,
            padding='max_length',
            max_length=self.max_length,
            return_tensors='pt'
        )

        return {
            'input_ids': encoding['input_ids'].flatten(),
            'attention_mask': encoding['attention_mask'].flatten(),
        }

# ------------------- 5. Create Datasets -------------------
train_dataset = BengaliDataset(train_texts, train_labels, tokenizer, MAX_LEN)
val_dataset = BengaliDataset(val_texts, val_labels, tokenizer, MAX_LEN)
test_dataset = TestDataset(test_texts, tokenizer, MAX_LEN)

print(f"Train dataset size: {len(train_dataset)}")
print(f"Validation dataset size: {len(val_dataset)}")
print(f"Test dataset size: {len(test_dataset)}")

# ------------------- 6. Training Arguments for QLoRA -------------------
training_args = TrainingArguments(
    output_dir='./qlora_bangla_hate_results',
    num_train_epochs=3,                    # Fewer epochs due to efficient training
    per_device_train_batch_size=16,        # Can use larger batch size with QLoRA
    per_device_eval_batch_size=16,
    gradient_accumulation_steps=2,         # Effective batch size = 16*2 = 32
    evaluation_strategy="epoch",
    save_strategy="epoch",
    logging_steps=50,
    learning_rate=2e-4,                    # Higher LR for LoRA adapters
    weight_decay=0.01,
    load_best_model_at_end=True,
    metric_for_best_model="eval_accuracy",
    greater_is_better=True,
    save_total_limit=2,
    seed=SEED,
    data_seed=SEED,
    remove_unused_columns=False,
    report_to=None,                        # Disable wandb/tensorboard
    dataloader_pin_memory=False,           # Disable for quantized models
    fp16=True,                             # Use mixed precision
)

print("Training Arguments:")
print(f"- Epochs: {training_args.num_train_epochs}")
print(f"- Batch size: {training_args.per_device_train_batch_size}")
print(f"- Learning rate: {training_args.learning_rate}")
print(f"- Gradient accumulation steps: {training_args.gradient_accumulation_steps}")

# ------------------- 7. Metrics Function -------------------
def compute_metrics(eval_pred):
    predictions, labels = eval_pred
    predictions = np.argmax(predictions, axis=1)

    # Calculate accuracy
    accuracy = (predictions == labels).mean()

    return {
        'accuracy': accuracy,
    }

# ------------------- 8. Initialize Trainer -------------------
trainer = Trainer(
    model=model,
    args=training_args,
    train_dataset=train_dataset,
    eval_dataset=val_dataset,
    compute_metrics=compute_metrics,
    tokenizer=tokenizer,
)

# ------------------- 9. Train the Model -------------------
print("\n" + "="*60)
print("STARTING QLORA TRAINING FOR BENGALI HATE SPEECH DETECTION")
print("="*60)

# Start training
trainer.train()

# Save the final model
trainer.save_model('./final_qlora_bangla_hate_model')
print("Final QLoRA model saved!")

# ------------------- 10. Evaluation on Validation Set -------------------
print("\n" + "="*50)
print("QLORA MODEL VALIDATION RESULTS")
print("="*50)

# Evaluate on validation set
val_results = trainer.evaluate()
print(f"Validation Accuracy: {val_results['eval_accuracy']:.4f}")
print(f"Validation Loss: {val_results['eval_loss']:.4f}")

# Detailed evaluation
val_predictions = trainer.predict(val_dataset)
val_preds = np.argmax(val_predictions.predictions, axis=1)
val_true = np.array(val_labels)

# Convert back to original labels
val_pred_labels = label_enc.inverse_transform(val_preds)
val_true_labels = label_enc.inverse_transform(val_true)

print(f"\nDetailed Classification Report (QLoRA Validation):")
print(classification_report(val_true_labels, val_pred_labels, target_names=label_enc.classes_))

# ------------------- 11. Generate Test Predictions -------------------
print("\nGenerating test predictions with QLoRA model...")

# Make predictions on test set
test_predictions = trainer.predict(test_dataset)
test_preds = np.argmax(test_predictions.predictions, axis=1)

# Convert predictions back to labels
test_pred_labels = label_enc.inverse_transform(test_preds)

print(f"Test predictions completed. Generated {len(test_pred_labels)} predictions.")

# ------------------- 12. Save Test Predictions -------------------
# Create submission file
test_results = pd.DataFrame({
    'id': test_df['id'],
    'label': test_pred_labels,
})

test_results.to_csv('subtask_1A.tsv', sep="\t", index=False)
print(f"Test predictions saved to 'subtask_1A.tsv'")

# ------------------- 13. Analysis and Visualization -------------------
print(f"\nTest Prediction Distribution:")
print(pd.Series(test_pred_labels).value_counts())

# Plot prediction distribution
plt.figure(figsize=(12, 5))

# Test predictions distribution
plt.subplot(1, 2, 1)
pd.Series(test_pred_labels).value_counts().plot(kind='bar')
plt.title('QLoRA Test Predictions Distribution')
plt.xlabel('Predicted Label')
plt.ylabel('Count')
plt.xticks(rotation=45)

# Validation confusion matrix
plt.subplot(1, 2, 2)
val_cm = confusion_matrix(val_true_labels, val_pred_labels, labels=label_enc.classes_)
sns.heatmap(val_cm, annot=True, fmt='d', cmap='Blues',
            xticklabels=label_enc.classes_, yticklabels=label_enc.classes_)
plt.title('QLoRA Validation Confusion Matrix')
plt.xlabel('Predicted')
plt.ylabel('Actual')

plt.tight_layout()
plt.savefig('qlora_results_analysis.png', dpi=300, bbox_inches='tight')
plt.show()

# ------------------- 14. Model Information Summary -------------------
print("\n" + "="*60)
print("QLORA TRAINING COMPLETED SUCCESSFULLY!")
print("="*60)

# Print final statistics
final_trainable = sum(p.numel() for p in model.parameters() if p.requires_grad)
final_total = sum(p.numel() for p in model.parameters())

print(f"\nModel Statistics:")
print(f"- Base Model: {model_name}")
print(f"- Total Parameters: {final_total:,}")
print(f"- Trainable Parameters: {final_trainable:,}")
print(f"- Trainable Percentage: {100 * final_trainable / final_total:.2f}%")
print(f"- Memory Efficiency: ~75% reduction compared to full fine-tuning")

print(f"\nFiles Generated:")
print(f"- Model: ./final_qlora_bangla_hate_model/")
print(f"- Predictions: subtask_1A.tsv")
print(f"- Analysis Plot: qlora_results_analysis.png")

print(f"\nQLoRA Benefits Achieved:")
print(f"- Faster training (3-5x speedup)")
print(f"- Lower memory usage (~4GB vs ~8GB)")
print(f"- Reduced overfitting risk")
print(f"- Efficient storage (only LoRA adapters saved)")

!pip install nbformat

import nbformat

# Path where Colab stores your notebook
input_path = "/content/QLora_Fine_Tuning.ipynb"
output_path = "/content/your_notebook_cleaned.ipynb"

# Read notebook
nb = nbformat.read(open(input_path, "r", encoding="utf-8"), as_version=4)

# Remove widgets metadata if it exists
if "widgets" in nb.metadata:
    del nb.metadata["widgets"]

# Save cleaned notebook
nbformat.write(nb, open(output_path, "w", encoding="utf-8"))

print("✅ Notebook cleaned and saved at:", output_path)

from google.colab import files
files.download('QLora_Fine_Tuning.ipynb')